[{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"https://shubozhang.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"OWASP 十大信息安全主题   注入攻击 （Injection） 无效身份认证（Broken Authentication 敏感信息泄漏（Sensitive Data Exposure） XML外部处理器漏洞（XML External Entities (XXE)） 无效存取控管（Broken Access Control） 错误设置安全系统（Security Misconfiguration） 跨站攻击（Cross-Site Scripting (XSS)） 不安全的反序列化漏洞（Insecure Deserialization） 使用已有漏洞元件（Using Components with Known Vulnerabilities） 日志和监控不足风险（Insufficient Logging and Monitoring）   敏感信息泄漏 Many web applications and APIs do not properly protect sensitive data, such as financial, healthcare, and PII. Attackers may steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes. Sensitive data may be compromised without extra protection, such as encryption at rest or in transit, and requires special precautions when exchanged with the browser.\n了解敏感信息泄漏 Sensitive data pii personally identifiable information, PHI personal health information and an entire gamut of proprietary data\nmust be protected in all applications.\nWhat do you need to know?\nConsider who can gain access to your sensitive data, and any backups of that data. This includes the data at rest, in transit, and even in your customers browsers. Include both external and internal threats.\nRather than directly attacking crypto, attackers steel keys execute man-in-the-middle attacks or steel clear text data off the server while in transit or from the users client, like a browser.\nA manual attack is generally required. Previously retrieved password database, this could be forced by graphics processing units, gpus.\nOver the last few years, this has been the most common impactful attack.\nThe most common flaw is simply not encrypting sensitive data. When crypto is employed, week key generation and management, as well as weak algorithm, protocol ,and cyber usage is common, particularly for weak password hashing storage techniques.\nFor data in transit, server side weaknesses are mainly easy to detect, but hard for data at rest.\nFailure frequently compromises all data that should have been protected. Typically, this information, including sensitive personally identifiable information data (PPI), such as health records, credentials, personal data, and credit cards, which often require protection as defined by laws or regulations, such as the EU GDPR or local privacy laws.\nConsider the business value of the lost data and the impact or possible damage to your reputation.\nWhat is your legal liability that this data is exposed?\nThe first thing you have to determine is which data is sensitive enough to require extra protection both in transit and at rest.\nFor examples, passwords, credit card numbers, health records, personal information, and business secrets require extra protection.\nParticularly if that data falls under privacy laws or regulations, like EU\u0026rsquo;s general data protection regulation gdpr, or regulations for financial data protection, such as pci data security standard (pci DSS).\nFor all such data, is any data transmitted in clear text, this concerns protocols, such as http, SMTP, and ftp.\nExternal internet traffic is especially dangerous, verifying all internal traffic between load balancers, web servers or back end systems.\nIs sensitive data stored in clear text, including backups? Are any old or weak cryptographic algorithms use either by default or in older code?\nAre default crypto keys in use, weak crypto keys generated or re-used, or is proper key management for rotation missing?\nIs encryption not enforced? Are any user agent browser security directives or headers missing?\nDoes user agent(like app, mail client) not verify if the received server certificate is valid?\nIs the data included as plain text and application or server logs?\n案例 scenario one An application encrypts credit card numbers in a database using automatic database encryption. However, this data is automatically decrypted when retrieved allowing a sequel injection flaw can retrieve credit card numbers in clear text.\nscenario two the site doesn\u0026rsquo;t use or enforce TLS for all pages or supports weak encryption. An attacker monitors network traffic(as at an insecure wireless network) downgrades connections from https to http, intercepts requests, and steals the users' session cookie.\nThe attacker then replays this cookie and hijacks the users authenticated session, accessing or modifying the users' private data. Instead of above, they could alter all transported data, like the recipient of a money transfer\nscenario three. The password database and uses unsalted or simple hashes to store everyone\u0026rsquo;s passwords. A file upload flaw allows an attacker to retrieve the password database. All the unsalted hashes can be exposed with the Rainbow table of pre-calculated hashes. Hashes generated by simple or fast hash functions may be crackered by GPUs, even if they were salted.\n预防 all sensitive data to all of the following and then.\n  classify data processed, stored, or transmitted by an application. Identify which data is sensitive according to privacy laws, regulatory requirements, or business needs.\n  Apply controls as proposed application. Don\u0026rsquo;t store sensitive data unnecessarily. Discard it as soon as possible or use PCI DSS compliant tokenization or even truncation. Data that is not retained cannot be stolen.\n  Make sure to encrypt all sensitive data at rest. Ensure up-to-date and strong standard algorithms, protocols, and keys are in place; use property key management.\n  Encrypt all data in transit with secure protocols, such as TLS with perfect forward secrecy(PFS) ciphers, cipher prioritization by server, and secure parameters. Enforce encryption using directives like http strict transport security(HSTS).\n  disable caching for responses that contain sensitive data.\nStore passwords using a strong adaptive and salted hashing function with a work factor(delay factor), such as Argon2, scrypt, bcrypt, or PBKDF2.\n  Verify independently the effectiveness of configuration and settings.\n  ","date":"April 14, 2021","hero":"/posts/tools/owasp-cn-03/owasp-top-ten.jpg","permalink":"https://shubozhang.github.io/posts/tools/owasp-cn-03/","summary":"OWASP 十大信息安全主题   注入攻击 （Injection） 无效身份认证（Broken Authentication 敏感信息泄漏（Sensitive Data Exposure） XML外部处理器漏洞（XML External Entities (XXE)） 无效存取控管（Broken Access Control） 错误设置安全系统（Security Misconfiguration） 跨站攻击（Cross-Site Scripting (XSS)） 不安全的反序列化漏洞（Insecure Deserialization） 使用已有漏洞元件（Using Components with Known Vulnerabilities） 日志和监控不足风险（Insufficient Logging and Monitoring）   敏感信息泄漏 Many web applications and APIs do not properly protect sensitive data, such as financial, healthcare, and PII. Attackers may steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes.","tags":null,"title":"OWASP 十大网站安全风险 （三）：敏感信息泄漏"},{"categories":null,"contents":"OWASP 十大信息安全主题   注入攻击 （Injection） 无效身份认证（Broken Authentication） 敏感信息泄漏（Sensitive Data Exposure） XML外部处理器漏洞（XML External Entities (XXE)） 无效存取控管（Broken Access Control） 错误设置安全系统（Security Misconfiguration） 跨站攻击（Cross-Site Scripting (XSS)） 不安全的反序列化漏洞（Insecure Deserialization） 使用已有漏洞元件（Using Components with Known Vulnerabilities） 日志和监控不足风险（Insufficient Logging and Monitoring）   无效身份认证 程序开发中，既要保证安全，又要有好的用户体验，身份认证，授权，和session管理很容易出现错误漏洞，攻击者可以利用这些漏洞来穿透认证检查，从而可以临时或者永久的使用其他人的账户。\n了解无效身份认证 对于需要保存状态的应用程序，身份认证，授权，session管理等的设计和执行很容易出现漏洞。尤其是session管理，它是身份认证，授权等的基石，攻击者大多 会对过期令牌进行攻击。\n攻击者有海量的有效用户名和密码组合，这些数据可以使用在\n  撞库攻击（credential stuffing attack）\n  默认管理员账户列表\n  自动暴力破解\n  字典攻击工具\n  攻击者能通过以上手段发现无效身份认证漏洞， 一般来说，攻击者只需要几个账户，或者一个管理员账户，就能侵入，破坏系统，这样可能会造成很严重的后果，例如 洗钱，盗窃身份，重要敏感信息泄漏 等等。\n什么情况容易被攻击   允许撞库攻击\n  允许暴力破解\n  允许默认或者非常弱的密码，例如 \u0026ldquo;Password1\u0026rdquo; 和 \u0026ldquo;admin/admin\u0026rdquo;\n  在密码恢复时，使用没有保护力的问题认证， 例如使用常识知识类的问题\n  使用简单，弱的加密密码，例如Base64\n  没有使用多重要素认证（MFA）\n  在URL中暴露session IDs\n  登陆成功后没有更新session令牌\n  在退出登陆后，或者用户一段时间没有活动时，没有及时使session或者授权令牌失效，尤其是单点登陆系统\n  案例 案例一 撞库攻击（来自百度百科） 很多用户在不同网站使用的是相同的帐号密码，因此黑客可以通过获取用户在A网站的账户从而尝试登录B网址，这就可以理解为撞库攻击。 撞库可采用大数据安全技术来防护，比如：用数据资产梳理发现敏感数据，使用数据库加密保护核心数据，使用数据库安全运维防运维人员撞库攻击等。\n案例二 授权认证攻击 曾经流行的密码最佳实践是定期更换密码，并且要求一定的复杂度。这个实践导致一些用户重复使用，或者使用固定模式的弱密码。NIST 800-63建议 停止使用上面的最佳实践，改用多重要素授权认证。\n案例三 session攻击 应用程序的session timeouts设置不合理. 例如，一个用户在公共计算机上登陆一个系统，使用后，没有退出，而是关闭了浏览器然后离开了。 这样攻击者可以在这位用户之后使用这台计算机中的同一个浏览器，用户的授权仍然是有效的。\n预防 首先要避免上面容易被攻击的情况。下面是一些具体措施\n  尽量使用多重要素认证（multi-factor authentication）， 它可以预防\n 机器登陆 撞库攻击 暴力破解 重用丢失密码攻击    在部署过程中不要使用默认密码，尤其是管理员用户\n  对密码进行强弱验证，例如测试最差的一万个密码列表\n  遵循NIST 800-63指导原则，对密码长度，复杂度，更新频率制定计划\n  在注册，密码登陆，密码恢复等功能中要防止枚举攻击，保证对所有错误尝试返回同样的错误信息\n  限制登陆尝试次数，监控短时间内密集登陆错误，及时警报给管理员\n  使用服务器端的session管理，用户登陆后，产生一个高熵的随机数作为session ID，这个ID不能出现在URL里面，应该被安全的保存，并且在用户退出登陆， 空闲无活动， 或者超时的时候，注销session ID\n  ","date":"April 9, 2021","hero":"/posts/tools/owasp-cn-02/owasp-top-ten.jpg","permalink":"https://shubozhang.github.io/posts/tools/owasp-cn-02/","summary":"OWASP 十大信息安全主题   注入攻击 （Injection） 无效身份认证（Broken Authentication） 敏感信息泄漏（Sensitive Data Exposure） XML外部处理器漏洞（XML External Entities (XXE)） 无效存取控管（Broken Access Control） 错误设置安全系统（Security Misconfiguration） 跨站攻击（Cross-Site Scripting (XSS)） 不安全的反序列化漏洞（Insecure Deserialization） 使用已有漏洞元件（Using Components with Known Vulnerabilities） 日志和监控不足风险（Insufficient Logging and Monitoring）   无效身份认证 程序开发中，既要保证安全，又要有好的用户体验，身份认证，授权，和session管理很容易出现错误漏洞，攻击者可以利用这些漏洞来穿透认证检查，从而可以临时或者永久的使用其他人的账户。\n了解无效身份认证 对于需要保存状态的应用程序，身份认证，授权，session管理等的设计和执行很容易出现漏洞。尤其是session管理，它是身份认证，授权等的基石，攻击者大多 会对过期令牌进行攻击。\n攻击者有海量的有效用户名和密码组合，这些数据可以使用在\n  撞库攻击（credential stuffing attack）\n  默认管理员账户列表\n  自动暴力破解\n  字典攻击工具\n  攻击者能通过以上手段发现无效身份认证漏洞， 一般来说，攻击者只需要几个账户，或者一个管理员账户，就能侵入，破坏系统，这样可能会造成很严重的后果，例如 洗钱，盗窃身份，重要敏感信息泄漏 等等。\n什么情况容易被攻击   允许撞库攻击\n  允许暴力破解\n  允许默认或者非常弱的密码，例如 \u0026ldquo;Password1\u0026rdquo; 和 \u0026ldquo;admin/admin\u0026rdquo;","tags":null,"title":"OWASP 十大网站安全风险 （二）：无效身份认证"},{"categories":null,"contents":"OWASP是 open web application security project 的缩写。这个系列主要介绍这十个最多被攻击的安全漏洞。\nOWASP 十大信息安全主题   注入攻击 （Injection） 无效身份认证（Broken Authentication） 敏感信息泄漏（Sensitive Data Exposure） XML外部处理器漏洞（XML External Entities (XXE)） 无效存取控管（Broken Access Control） 错误设置安全系统（Security Misconfiguration） 跨站攻击（Cross-Site Scripting (XSS)） 不安全的反序列化漏洞（Insecure Deserialization） 使用已有漏洞元件（Using Components with Known Vulnerabilities） 日志和监控不足风险（Insufficient Logging and Monitoring）   注入攻击 注入攻击是指在SQL, NoSQL, 系统命令, 和 LDAP等注入时候, 非安全的数据作为命令或者语句传入到解释器中，这些攻击者的 敌对数据可以骗过解释器，在没有授权的情况下执行一些危险命令或者取得数据\n了解注入攻击   首先要考虑到，外部用户， 内部用户， 管理员等都可能给系统发送非安全信息。当攻击者给解释器发送敌对数据的时候，注入 攻击就发生了。\n  注入漏洞是非常普遍的，尤其是老旧系统。 最可能出现的地方包括SQL, LDAP, XPath, OS 命令, XML parsers, smtp headers, Expression languages， ORM语句， OGNL（object graph navigation library）等等.\n  通过检查代码是很容见发现注入漏洞的。攻击者经常用扫描软件或者模糊测试软件去找注入漏洞。\n  注入漏洞能导致很多严重后果，像数据丢失，数据损坏，数据泄漏，数据授权被破坏，有时候可能导致整个系统完全被攻击之掌控\n  什么样的应用程序容易被攻击  程序对用户提交的数据不验证，不过滤，不清理。 动态SQL语句，或者非参数注入语句没有对特殊符号处理就直接传入解释器。 非验证数据直接用在ORM搜索参数里面 非验证数据直接用在SQL， 系统命令，动态SQL， 或者存储过程里  预防注入攻击的最好方法是代码审查，然后是对下面等数据输入进行严格测试：\n Parameters Headers URL Cookies JSON SOAP XML  现在公司基本会在CI/CD pipeline加入一些扫描，测试软件来发现这些漏洞。\n注入漏洞攻击实例 例子一： 程序使用非验证数据去创建SQL语句\nString query = \u0026quot;SELECT * FROM accounts WHERE custID='\u0026quot;+ request.getParameter(\u0026quot;id\u0026quot;) + \u0026quot;'\u0026quot;; 例子二： 程序使用非验证数据去创建HQL语句\nQuery HQLQuery = session.createQuery(\u0026quot;FROM accounts WHERE custID='\u0026quot;+request.getParameter(\u0026quot;id\u0026quot;)+\u0026quot;'\u0026quot;); 在上面两个例子中，攻击者可以在浏览器篡改id参数， 发送' or '1'='1\nExample: http://example.com/app/accountView?id=' or '1'='1 这样上面两个query会返回accounts表里所有数据。所以可以看出，注入攻击是非常严重，完全可以取得， 破坏数据。\n预防注入漏洞  要把非验证数据和queries， 系统命令之类的非开 使用安全API, 完全避免使用解释器 使用参数化接口 如果没有参数化API的话，我们必须在解释器里很小心去处理特殊符号。 可以积极的对输入数据进行验证，但很多系统要求特殊符号作为输入，这样就很难完全检查到注入漏洞了。 使用关键字LIMIT或者其他SQL query控制，避免返回大量数据。  ","date":"April 7, 2021","hero":"/posts/tools/owasp-cn-01/owasp-top-ten.jpg","permalink":"https://shubozhang.github.io/posts/tools/owasp-cn-01/","summary":"OWASP是 open web application security project 的缩写。这个系列主要介绍这十个最多被攻击的安全漏洞。\nOWASP 十大信息安全主题   注入攻击 （Injection） 无效身份认证（Broken Authentication） 敏感信息泄漏（Sensitive Data Exposure） XML外部处理器漏洞（XML External Entities (XXE)） 无效存取控管（Broken Access Control） 错误设置安全系统（Security Misconfiguration） 跨站攻击（Cross-Site Scripting (XSS)） 不安全的反序列化漏洞（Insecure Deserialization） 使用已有漏洞元件（Using Components with Known Vulnerabilities） 日志和监控不足风险（Insufficient Logging and Monitoring）   注入攻击 注入攻击是指在SQL, NoSQL, 系统命令, 和 LDAP等注入时候, 非安全的数据作为命令或者语句传入到解释器中，这些攻击者的 敌对数据可以骗过解释器，在没有授权的情况下执行一些危险命令或者取得数据\n了解注入攻击   首先要考虑到，外部用户， 内部用户， 管理员等都可能给系统发送非安全信息。当攻击者给解释器发送敌对数据的时候，注入 攻击就发生了。\n  注入漏洞是非常普遍的，尤其是老旧系统。 最可能出现的地方包括SQL, LDAP, XPath, OS 命令, XML parsers, smtp headers, Expression languages， ORM语句， OGNL（object graph navigation library）等等.","tags":null,"title":"OWASP 十大网站安全风险 （一）： 注入攻击"},{"categories":null,"contents":"先扯扯为啥用DynamoDB，简单说就是公司没有或者没人愿意干DBA，SRE也不想干这活。。。感觉到了cloud后，DBA都华丽转身大数据了，不屑于在搞RDS。 还有些公司搞\u0026quot;you write it， you deploy it，and you maintain it\u0026quot;，一个组要负责自己的产品，从UI到DB，个个都要full-stack。DynamoDB就属于Developer完全可以搞定的， 不需要DBA或者SRE帮忙。 一般业务不需要多表join的，DynamoDB设计好了都没问题，还是有些dev说，我们的业务需要ACID，今天就来打脸了，Transaction is not a deal breaker for Dynamodb anymore。\nDynamoDB Transaction保证ACID。ACID意思是atomicity, consistency, isolation, and durability。这里主要谈的是atomicity，同时操作 多个表或者行，结果要是all or nothing，全部操作成功，或者什么都不做。\n两个Transactional API   TransactWriteItems\n 一个transaction最多操作25个不用的items，每个item大小不超过400 KB，整个transaction大小不超过4 MB。 同一个transaction只能操作同一个item一次。 消耗双倍WCUs。 可以用client token来保持幂等(10 mins)。    TransactReadItems\n 一个transaction最多操作25个不用的GET，整个transaction大小不超过4 MB。 返回的是同步读的结果。 消耗双倍RCUs。 读写都不用锁，有冲突就会取消transaction，需要自己处理retry。注意，即使但transaction取消了，还是消耗同样的capacity units。    其他：\n transaction读写都不用锁，有冲突就会取消transaction，需要自己处理retry。注意，即使但transaction取消了，还是消耗同样的capacity units。 transaction必须在同一个AWS region transaction必须在同一个AWS 账户 transaction必须在DynamoDB里    例子 源码： https://github.com/shubozhang/micronaut-with-java/blob/main/mn-dynamodb/src/test/java/com/sz/transaction/TransactionTest.java\n建立三个table 1.Table Account: unique accountId\n@NoArgsConstructor @AllArgsConstructor @DynamoDBTable(tableName=\u0026#34;Account\u0026#34;) @ToString @Data public class Account { private String accountId; @DynamoDBHashKey(attributeName = \u0026#34;AccountId\u0026#34;) public String getAccountId() { return accountId; } public void setAccountId(String accountId) { this.accountId = accountId; } } Table Room：unique RoomId，属性available只能是YES或者NO  @NoArgsConstructor @AllArgsConstructor @DynamoDBTable(tableName=\u0026#34;Room\u0026#34;) @ToString @Data public class Room { private String roomId; private String available; public Room(String roomId) { this.roomId = roomId; } @DynamoDBHashKey(attributeName = \u0026#34;RoomId\u0026#34;) public String getRoomId() { return roomId; } public void setRoomId(String roomId) { this.roomId = roomId; } @DynamoDBAttribute(attributeName = \u0026#34;Available\u0026#34;) public String getAvailable() { return available; } public void setAvailable(String available) { this.available = available; } } Table Order：unique orderId，accountId必须是存在的，roomId也必须是存在的，并且对应的room available必须是之前YES， 之后NO  @NoArgsConstructor @AllArgsConstructor @DynamoDBTable(tableName=\u0026#34;Order\u0026#34;) @ToString @Data public class Order { private String orderId; private String accountId; private String roomId; public Order(String orderId) { this.orderId = orderId; } @DynamoDBHashKey(attributeName = \u0026#34;OrderId\u0026#34;) public String getOrderId() { return orderId; } public void setOrderId(String orderId) { this.orderId = orderId; } @DynamoDBAttribute(attributeName = \u0026#34;AccountId\u0026#34;) public String getAccountId() { return accountId; } public void setAccountId(String accountId) { this.accountId = accountId;} @DynamoDBAttribute(attributeName = \u0026#34;RoomId\u0026#34;) public String getRoomId() { return roomId; } public void setRoomId(String roomId) { this.roomId = roomId; } } 写Transaction  Create an order   private String createOrder(Order order) { // 1。 先检查accountId DynamoDBTransactionWriteExpression checkAccount = new DynamoDBTransactionWriteExpression() .withConditionExpression(\u0026quot;attribute_exists(AccountId)\u0026quot;); // 2。检查Room是不是available，操作之前的status必须是YES。 Map\u0026lt;String, AttributeValue\u0026gt; roomUpdateValues = new HashMap\u0026lt;\u0026gt;(); roomUpdateValues.put(\u0026quot;:pre_status\u0026quot;, new AttributeValue(\u0026quot;YES\u0026quot;)); DynamoDBTransactionWriteExpression checkRoom = new DynamoDBTransactionWriteExpression() .withExpressionAttributeValues(roomUpdateValues) .withConditionExpression(\u0026quot;Available = :pre_status\u0026quot;); // 3。检查没有重复的order DynamoDBTransactionWriteExpression checkOrder = new DynamoDBTransactionWriteExpression() .withConditionExpression(\u0026quot;attribute_not_exists(OrderId)\u0026quot;); TransactionWriteRequest transactionWriteRequest = new TransactionWriteRequest(); transactionWriteRequest.addConditionCheck(new Account(order.getAccountId()), checkAccount); // 更新房间状态，预定后变为NO transactionWriteRequest.addUpdate(new Room(order.getRoomId(), \u0026quot;NO\u0026quot;), checkRoom); transactionWriteRequest.addPut(order, checkOrder); // 4。 写Transaction return executeTransactionWrite(transactionWriteRequest); } Execute Transaction Write   private static String executeTransactionWrite(TransactionWriteRequest transactionWriteRequest) { try { mapper.transactionWrite(transactionWriteRequest); } catch (DynamoDBMappingException ddbme) { return (\u0026quot;Client side error in Mapper, fix before retrying. Error: \u0026quot; + ddbme.getMessage()); } catch (ResourceNotFoundException rnfe) { return (\u0026quot;One of the tables was not found, verify table exists before retrying. Error: \u0026quot; + rnfe.getMessage()); } catch (InternalServerErrorException ise) { return (\u0026quot;Internal Server Error, generally safe to retry with back-off. Error: \u0026quot; + ise.getMessage()); } catch (TransactionCanceledException tce) { // 重点测试这个exception，它返回的信息会准确告诉我们哪一步有错误 return (\u0026quot;Transaction Canceled, implies a client issue, fix before retrying. Error: \u0026quot; + tce.getMessage()); } catch (Exception ex) { return (\u0026quot;An exception occurred, investigate and configure retry strategy. Error: \u0026quot; + ex.getMessage()); } return \u0026quot;SUCCESS\u0026quot;; } 读Transaction  Read an order：读出order，和相关的ROOM，ACCOUNT信息   private List\u0026lt;Object\u0026gt; readOrder(Order order) { TransactionLoadRequest transactionLoadRequest = new TransactionLoadRequest(); transactionLoadRequest.addLoad(order); transactionLoadRequest.addLoad(new Room(order.getRoomId())); transactionLoadRequest.addLoad(new Account(order.getAccountId())); return executeTransactionLoad(transactionLoadRequest); } Execute Transaction Load   private static List\u0026lt;Object\u0026gt; executeTransactionLoad(TransactionLoadRequest transactionLoadRequest) { List\u0026lt;Object\u0026gt; loadedObjects = new ArrayList\u0026lt;Object\u0026gt;(); try { loadedObjects = mapper.transactionLoad(transactionLoadRequest); } catch (DynamoDBMappingException ddbme) { System.err.println(\u0026quot;Client side error in Mapper, fix before retrying. Error: \u0026quot; + ddbme.getMessage()); } catch (ResourceNotFoundException rnfe) { System.err.println(\u0026quot;One of the tables was not found, verify table exists before retrying. Error: \u0026quot; + rnfe.getMessage()); } catch (InternalServerErrorException ise) { System.err.println(\u0026quot;Internal Server Error, generally safe to retry with back-off. Error: \u0026quot; + ise.getMessage()); } catch (TransactionCanceledException tce) { System.err.println(\u0026quot;Transaction Canceled, implies a client issue, fix before retrying. Error: \u0026quot; + tce.getMessage()); } catch (Exception ex) { System.err.println(\u0026quot;An exception occurred, investigate and configure retry strategy. Error: \u0026quot; + ex.getMessage()); } return loadedObjects; } 准备测试数据  // 插入5个account，A1。。。A5 private static void insertAccounts(Integer count) { AccountDao accountDao = new AccountDao(); for (int i = 0; i \u0026lt; count; i++) { accountDao.saveItem(new Account(\u0026quot;A\u0026quot;+i)); } } // 插入5个room，R1。。。R5，初始状态是YES private static void insertRooms(Integer count) { RoomDao roomDao = new RoomDao(); for (int i = 0; i \u0026lt; count; i++) { roomDao.saveItem(new Room(\u0026quot;R\u0026quot;+i, \u0026quot;YES\u0026quot;)); } } 测试一：完成order @Test public void testCreateOrder() { // 新建order Order order = new Order(); order.setOrderId(\u0026quot;1\u0026quot;); order.setAccountId(\u0026quot;A1\u0026quot;); order.setRoomId(\u0026quot;R1\u0026quot;); // 创建order createOrder(order); // 读order List\u0026lt;Object\u0026gt; objects = readOrder(order); Order resOrder = (Order) objects.get(0); Room resRoom = (Room) objects.get(1); Account resAccount = (Account) objects.get(2); // 检查结果 assertThat(resOrder).isEqualTo(order); assertThat(resAccount).isEqualTo(new Account(order.getAccountId())); assertTrue(resRoom.getRoomId().equals(order.getRoomId()) \u0026amp;\u0026amp; resRoom.getAvailable().equals(\u0026quot;NO\u0026quot;)); // clean up deleteOrder(order); } 测试二：无效account  @Test public void testInvalidAccountException() { Order order = new Order(); order.setOrderId(\u0026quot;2\u0026quot;); order.setAccountId(\u0026quot;A\u0026quot;); order.setRoomId(\u0026quot;R3\u0026quot;); String res = createOrder(order); assertTrue(res.contains(\u0026quot;Transaction Canceled, implies a client issue, fix before retrying. Error: \u0026quot;)); // 第一个conditionCheck就是accountId assertTrue(res.contains(\u0026quot;[ConditionalCheckFailed, None, None]\u0026quot;)); } 测试三：无效room  @Test public void testInvalidRoomException() { Order order = new Order(); order.setOrderId(\u0026quot;2\u0026quot;); order.setAccountId(\u0026quot;A2\u0026quot;); order.setRoomId(\u0026quot;R\u0026quot;); String res = createOrder(order); assertTrue(res.contains(\u0026quot;Transaction Canceled, implies a client issue, fix before retrying. Error: \u0026quot;)); // 第二个conditionCheck是Room assertTrue(res.contains(\u0026quot;[None, ConditionalCheckFailed, None]\u0026quot;)); } 测试四：重复room  @Test public void testDupRoomException() { Order order = new Order(); order.setOrderId(\u0026quot;2\u0026quot;); order.setAccountId(\u0026quot;A2\u0026quot;); order.setRoomId(\u0026quot;R2\u0026quot;); String res = createOrder(order); assertTrue(res.equals(\u0026quot;SUCCESS\u0026quot;)); Order order2 = new Order(); order2.setOrderId(\u0026quot;3\u0026quot;); order2.setAccountId(\u0026quot;A3\u0026quot;); order2.setRoomId(\u0026quot;R2\u0026quot;); String res2 = createOrder(order2); assertTrue(res2.contains(\u0026quot;Transaction Canceled, implies a client issue, fix before retrying. Error: \u0026quot;)); // 还是room conditionCheck 失败 assertTrue(res2.contains(\u0026quot;[None, ConditionalCheckFailed, None]\u0026quot;)); // clean up deleteOrder(order); } 测试五：重复order  @Test public void testDupOrderException() { Order order = new Order(); order.setOrderId(\u0026quot;2\u0026quot;); order.setAccountId(\u0026quot;A2\u0026quot;); order.setRoomId(\u0026quot;R2\u0026quot;); String res = createOrder(order); assertTrue(res.equals(\u0026quot;SUCCESS\u0026quot;)); Order order2 = new Order(); order2.setOrderId(\u0026quot;2\u0026quot;); order2.setAccountId(\u0026quot;A3\u0026quot;); order2.setRoomId(\u0026quot;R3\u0026quot;); String res2 = createOrder(order2); assertTrue(res2.contains(\u0026quot;Transaction Canceled, implies a client issue, fix before retrying. Error: \u0026quot;)); // order conditionCheck 失败 assertTrue(res2.contains(\u0026quot;[None, None, ConditionalCheckFailed]\u0026quot;)); // clean up deleteOrder(order); } 测试六：全无效  @Test public void testAllInvalidException() { Order order = new Order(); order.setOrderId(\u0026quot;2\u0026quot;); order.setAccountId(\u0026quot;A2\u0026quot;); order.setRoomId(\u0026quot;R2\u0026quot;); String res = createOrder(order); assertTrue(res.equals(\u0026quot;SUCCESS\u0026quot;)); Order order2 = new Order(); order2.setOrderId(\u0026quot;2\u0026quot;); order2.setAccountId(\u0026quot;NONE\u0026quot;); order2.setRoomId(\u0026quot;NONE\u0026quot;); String res2 = createOrder(order2); assertTrue(res2.contains(\u0026quot;Transaction Canceled, implies a client issue, fix before retrying. Error: \u0026quot;)); // 所有conditionCheck都失败 assertTrue(res2.contains(\u0026quot;[ConditionalCheckFailed, ConditionalCheckFailed, ConditionalCheckFailed]\u0026quot;)); // clean up deleteOrder(order); } 更多例子  https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.Transactions.html  ","date":"March 27, 2021","hero":"/posts/aws/dynamodb-acid/hero.svg","permalink":"https://shubozhang.github.io/posts/aws/dynamodb-acid/","summary":"先扯扯为啥用DynamoDB，简单说就是公司没有或者没人愿意干DBA，SRE也不想干这活。。。感觉到了cloud后，DBA都华丽转身大数据了，不屑于在搞RDS。 还有些公司搞\u0026quot;you write it， you deploy it，and you maintain it\u0026quot;，一个组要负责自己的产品，从UI到DB，个个都要full-stack。DynamoDB就属于Developer完全可以搞定的， 不需要DBA或者SRE帮忙。 一般业务不需要多表join的，DynamoDB设计好了都没问题，还是有些dev说，我们的业务需要ACID，今天就来打脸了，Transaction is not a deal breaker for Dynamodb anymore。\nDynamoDB Transaction保证ACID。ACID意思是atomicity, consistency, isolation, and durability。这里主要谈的是atomicity，同时操作 多个表或者行，结果要是all or nothing，全部操作成功，或者什么都不做。\n两个Transactional API   TransactWriteItems\n 一个transaction最多操作25个不用的items，每个item大小不超过400 KB，整个transaction大小不超过4 MB。 同一个transaction只能操作同一个item一次。 消耗双倍WCUs。 可以用client token来保持幂等(10 mins)。    TransactReadItems\n 一个transaction最多操作25个不用的GET，整个transaction大小不超过4 MB。 返回的是同步读的结果。 消耗双倍RCUs。 读写都不用锁，有冲突就会取消transaction，需要自己处理retry。注意，即使但transaction取消了，还是消耗同样的capacity units。    其他：\n transaction读写都不用锁，有冲突就会取消transaction，需要自己处理retry。注意，即使但transaction取消了，还是消耗同样的capacity units。 transaction必须在同一个AWS region transaction必须在同一个AWS 账户 transaction必须在DynamoDB里    例子 源码： https://github.","tags":null,"title":"NoSql也搞ACID：DynamoDB Transaction"},{"categories":null,"contents":"介绍 项目最近要升级Posgres数据库， 从9.6升级到12+。为了做一些migration测试，我本地要安装几个版本的Postgres，最方便的就是 用Docker安装了，没有版本冲突的问题，好管理，也方便删除。\n另外建议使用docker-compose，或者stack，简单说就是可以data存在本地，这样每次重新启动，数据不会丢，可以重复使用。如果 是做integration testing，则可以每次启动一个新的container。\n下面docker-compose文件里面还有pgAdmin，这样使用Postgres更方便。也可以使用自己喜欢的DB browser，我用IDEA（ultimate） 带的Database plugin。\n支持 Intel CPU 我在MacOS下用了一段时间，没问题。\n 保存成docker-compose.yml文件 在文件路径下运行 docker-compose up -d  说明：\n user和password自己随意设置 volumes是本地保存数据库的路径 ports：默认是5432。我一般喜欢改成15432，项目多了，10000下的port很拥挤 pgadmin的email和password是页面登陆密码 pgadmin的volumes和ports跟Postgres性质一样  version: \u0026#39;3.5\u0026#39; services: postgres: container_name: pg12 image: postgres:12 environment: POSTGRES_USER: pg12 POSTGRES_PASSWORD: pg12 PGDATA: /data/postgres volumes: - postgres12:/Users/szhang/postgresql/pg12 ports: - \u0026#34;5432:5432\u0026#34; networks: - pg12 restart: unless-stopped pgadmin: container_name: pgadmin12 image: dpage/pgadmin4 environment: PGADMIN_DEFAULT_EMAIL: a@gmail.com PGADMIN_DEFAULT_PASSWORD: a@gmail.com volumes: - pgadmin12:/Users/szhang/postgresql/.pgadmin12 ports: - \u0026#34;27777:80\u0026#34; networks: - pg12 restart: unless-stopped networks: pg12: driver: bridge volumes: postgres12: pgadmin12: 支持 Apple M1 这个版本唯一不同在于Postgres image 是ARM版本的，专门支持最新的Apple M1芯片的电脑。另外多说一句，Apple M1电脑可以跑Docker， 但是很多Docker image还没有ARM版，所以目前用M1电脑做开发（需要docker）还不方便。\nversion: \u0026#39;3.5\u0026#39; services: postgres: container_name: pg12 image: arm64v8/postgres:12.6 environment: POSTGRES_USER: pg12 POSTGRES_PASSWORD: pg12 PGDATA: /data/postgres volumes: - postgres12:/Users/shubozhang/dev/postgresql/pg12 ports: - \u0026#34;5432:5432\u0026#34; networks: - pg12 restart: unless-stopped pgadmin: container_name: pgadmin12 image: dpage/pgadmin4 environment: PGADMIN_DEFAULT_EMAIL: a@gmail.com PGADMIN_DEFAULT_PASSWORD: a@gmail.com volumes: - pgadmin12:/Users/shubozhang/dev/postgresql/.pgadmin12 ports: - \u0026#34;27777:80\u0026#34; networks: - pg12 restart: unless-stopped networks: pg12: driver: bridge volumes: postgres12: pgadmin12: 测试   pgAdmin\n  登陆，使用docker-compose里面的email和密码   使用界面     Intellij IDE\n使用用户名，密码，和端口就可以链接了。   ","date":"March 22, 2021","hero":"/posts/tools/pg12/pg.svg","permalink":"https://shubozhang.github.io/posts/tools/pg12/","summary":"介绍 项目最近要升级Posgres数据库， 从9.6升级到12+。为了做一些migration测试，我本地要安装几个版本的Postgres，最方便的就是 用Docker安装了，没有版本冲突的问题，好管理，也方便删除。\n另外建议使用docker-compose，或者stack，简单说就是可以data存在本地，这样每次重新启动，数据不会丢，可以重复使用。如果 是做integration testing，则可以每次启动一个新的container。\n下面docker-compose文件里面还有pgAdmin，这样使用Postgres更方便。也可以使用自己喜欢的DB browser，我用IDEA（ultimate） 带的Database plugin。\n支持 Intel CPU 我在MacOS下用了一段时间，没问题。\n 保存成docker-compose.yml文件 在文件路径下运行 docker-compose up -d  说明：\n user和password自己随意设置 volumes是本地保存数据库的路径 ports：默认是5432。我一般喜欢改成15432，项目多了，10000下的port很拥挤 pgadmin的email和password是页面登陆密码 pgadmin的volumes和ports跟Postgres性质一样  version: \u0026#39;3.5\u0026#39; services: postgres: container_name: pg12 image: postgres:12 environment: POSTGRES_USER: pg12 POSTGRES_PASSWORD: pg12 PGDATA: /data/postgres volumes: - postgres12:/Users/szhang/postgresql/pg12 ports: - \u0026#34;5432:5432\u0026#34; networks: - pg12 restart: unless-stopped pgadmin: container_name: pgadmin12 image: dpage/pgadmin4 environment: PGADMIN_DEFAULT_EMAIL: a@gmail.com PGADMIN_DEFAULT_PASSWORD: a@gmail.com volumes: - pgadmin12:/Users/szhang/postgresql/.pgadmin12 ports: - \u0026#34;27777:80\u0026#34; networks: - pg12 restart: unless-stopped networks: pg12: driver: bridge volumes: postgres12: pgadmin12: 支持 Apple M1 这个版本唯一不同在于Postgres image 是ARM版本的，专门支持最新的Apple M1芯片的电脑。另外多说一句，Apple M1电脑可以跑Docker， 但是很多Docker image还没有ARM版，所以目前用M1电脑做开发（需要docker）还不方便。","tags":null,"title":"本地Docker安装Postgres 12 + pgadmin （支持Apple M1)"},{"categories":null,"contents":"DynamoDB一直被人诟病没有好的query tool，查询数据很麻烦，到现在也没有。在就是本地开发不是很友好，AWS提供了Dynamodb Local，但是aws cli query数据 还是很麻烦。今天推荐一个给DynamoDB Local做的Graphical User Interface (GUI)\u0026mdash;dynamodb-admin，可以像在AWS console一样，让本地数据可视化和操作化。\n快速设置   通过npm安装dynamodb-admin\nnpm install -g dynamodb-admin   运行docker： local dynamodb\ndocker-compose.yml file\nversion: \u0026#39;3.8\u0026#39;services: dynamodb-local: command: \u0026#34;-jar DynamoDBLocal.jar -sharedDb -optimizeDbBeforeStartup -dbPath ./data\u0026#34; image: \u0026#34;amazon/dynamodb-local:latest\u0026#34; container_name: dynamodb-local ports: - \u0026#34;8000:8000\u0026#34; volumes: - \u0026#34;./docker/dynamodb:/home/dynamodblocal/data\u0026#34; working_dir: /home/dynamodblocalRun docker-compose.yml file\ndocker-compose up -d   启动dynamodb-admin\n MacOS： dynamodb-admin // 或者定义region和credentials AWS_REGION=eu-west-1 AWS_ACCESS_KEY_ID=local AWS_SECRET_ACCESS_KEY=local dynamodb-admin  Windows: export DYNAMO_ENDPOINT=http://localhost:8000 dynamodb-admin     完成\n DynamoDB 运行在 http://localhost:8000 图形界面运行在 http://localhost:8001    UI测试 我通过aws cli command新建了两个table， 来看看UI。\n  首页比较简洁，显示两个表。\n  选择Music table，显示items。可以GET，SCAN，QUERY数据。\n  从UI QUERY GSI\n  Meta 可以显示schema和表的一些统计\n  可以通过UI建表\n  支持本地CRUD测试应该足够用了。\nCRUD测试 建立一个简单的Micronaut webapp来测试CRUD DynamoDB table。\n源码：https://github.com/shubozhang/micronaut-with-java/blob/main/mn-dynamodb/\n  通过AWS CLI创建一个Music Table，Table包括一个本地索引和全局索引\naws dynamodb create-table --cli-input-json file://music_table.json --endpoint-url http://localhost:8000 music_table.json:\n{ \u0026#34;AttributeDefinitions\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;Artist\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34;}, { \u0026#34;AttributeName\u0026#34;: \u0026#34;SongTitle\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34;}, { \u0026#34;AttributeName\u0026#34;: \u0026#34;AlbumTitle\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34;}, { \u0026#34;AttributeName\u0026#34;: \u0026#34;Upc\u0026#34;, \u0026#34;AttributeType\u0026#34;: \u0026#34;S\u0026#34;} ], \u0026#34;TableName\u0026#34;: \u0026#34;Music\u0026#34;, \u0026#34;KeySchema\u0026#34;: [ { \u0026#34;KeyType\u0026#34;: \u0026#34;HASH\u0026#34;, \u0026#34;AttributeName\u0026#34;: \u0026#34;Artist\u0026#34; }, { \u0026#34;KeyType\u0026#34;: \u0026#34;RANGE\u0026#34;, \u0026#34;AttributeName\u0026#34;: \u0026#34;SongTitle\u0026#34; } ], \u0026#34;LocalSecondaryIndexes\u0026#34;: [ { \u0026#34;IndexName\u0026#34;: \u0026#34;lsi_album\u0026#34;, \u0026#34;KeySchema\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;Artist\u0026#34;, \u0026#34;KeyType\u0026#34;: \u0026#34;HASH\u0026#34;}, { \u0026#34;AttributeName\u0026#34;: \u0026#34;AlbumTitle\u0026#34;, \u0026#34;KeyType\u0026#34;: \u0026#34;RANGE\u0026#34;} ], \u0026#34;Projection\u0026#34;: { \u0026#34;ProjectionType\u0026#34;: \u0026#34;ALL\u0026#34; } } ], \u0026#34;ProvisionedThroughput\u0026#34;: { \u0026#34;ReadCapacityUnits\u0026#34;: 3, \u0026#34;WriteCapacityUnits\u0026#34;: 3 }, \u0026#34;GlobalSecondaryIndexes\u0026#34;: [ { \u0026#34;IndexName\u0026#34;: \u0026#34;gsi_upc\u0026#34;, \u0026#34;KeySchema\u0026#34;: [ { \u0026#34;AttributeName\u0026#34;: \u0026#34;Upc\u0026#34;, \u0026#34;KeyType\u0026#34;: \u0026#34;HASH\u0026#34;} ], \u0026#34;Projection\u0026#34;: { \u0026#34;ProjectionType\u0026#34;: \u0026#34;ALL\u0026#34; }, \u0026#34;ProvisionedThroughput\u0026#34;: { \u0026#34;ReadCapacityUnits\u0026#34;: 3, \u0026#34;WriteCapacityUnits\u0026#34;: 3 } } ] }   Create a model for Music Table\n@DynamoDBTable(tableName=\u0026#34;Music\u0026#34;) @ToString public class Music { private String artist; private String songTitle; private String albumTitle; private Integer year; private String upc; @DynamoDBHashKey(attributeName=\u0026#34;Artist\u0026#34;) public String getArtist() { return artist;} public void setArtist(String artist) {this.artist = artist;} @DynamoDBRangeKey(attributeName=\u0026#34;SongTitle\u0026#34;) public String getSongTitle() { return songTitle;} public void setSongTitle(String songTitle) {this.songTitle = songTitle;} @DynamoDBIndexRangeKey(attributeName = \u0026#34;AlbumTitle\u0026#34;, localSecondaryIndexName = \u0026#34;lsi_album\u0026#34;) public String getAlbumTitle() { return albumTitle;} public void setAlbumTitle(String albumTitle) {this.albumTitle = albumTitle;} @DynamoDBAttribute(attributeName = \u0026#34;Year\u0026#34;) public Integer getYear() { return year; } public void setYear(Integer year) { this.year = year; } @DynamoDBIndexHashKey(attributeName = \u0026#34;Upc\u0026#34;, globalSecondaryIndexName= \u0026#34;gsi_upc\u0026#34;) public String getUpc() { return upc; } public void setUpc(String upc) { this.upc = upc; } }  PartitionKey是由HashKey Artist和RangeKey SongTitle组成。 建立LSI IndexRangeKey AlbumTitle。它将和HashKey Artist一起用。 建立GSI IndexHashKey Upc。它可以单独引用。    建立一个DBMapper class。设置client， mapper，和index\npublic class DBMapper { private static final String TABLE_NAME = \u0026#34;Music\u0026#34;; private static final String LSI_ALBUM_INDEX_NAME = \u0026#34;lsi_album\u0026#34;; private static final String GSI_UPC_INDEX_NAME = \u0026#34;gsi_upc\u0026#34;; private static AmazonDynamoDB client; private static DynamoDBMapper mapper; private static Index lsi_album; private static Index gsi_upc; static { AWSCredentialsProvider creds = new AWSCredentialsProvider() { @Override public AWSCredentials getCredentials() { return new BasicAWSCredentials(\u0026#34;local\u0026#34;, \u0026#34;local\u0026#34;); } @Override public void refresh() { } }; client = AmazonDynamoDBClientBuilder.standard() .withCredentials(creds) .withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration(\u0026#34;http://localhost:8000\u0026#34;, \u0026#34;us-east-1\u0026#34;)) .build(); mapper = new DynamoDBMapper(client); DynamoDB dynamoDb = new DynamoDB(client); Table table = dynamoDb.getTable(TABLE_NAME); lsi_album = table.getIndex(LSI_ALBUM_INDEX_NAME); gsi_upc = table.getIndex(GSI_UPC_INDEX_NAME); } public static DynamoDBMapper getMapper(){ return mapper; } public static Index getLSIAlbumTitle() { return lsi_album; } public static Index getGSIUpc() { return gsi_upc; } }   Create a MusicDao for CRUD\n@Singleton public class MusicDao { private final DynamoDBMapper mapper = DBMapper.getMapper(); private final Index lsiAlbum = DBMapper.getLSIAlbumTitle(); private final Index gsiAlbum = DBMapper.getGSIUpc(); public Music getItem(Music music) { return mapper.load(music); } public void saveItem(Music music) { mapper.save(music); } public void deleteItem(Music music) { mapper.delete(music); } public List\u0026lt;Music\u0026gt; queryItemByLSI(Music music) throws JsonProcessingException { List\u0026lt;Music\u0026gt; musicList = new ArrayList\u0026lt;\u0026gt;(); QuerySpec spec = new QuerySpec() .withKeyConditionExpression(\u0026#34;Artist = :v_artist and AlbumTitle = :v_title\u0026#34;) .withValueMap(new ValueMap() .withString(\u0026#34;:v_artist\u0026#34;, music.getArtist()) .withString(\u0026#34;:v_title\u0026#34;, music.getAlbumTitle())); ItemCollection\u0026lt;QueryOutcome\u0026gt; items = lsiAlbum.query(spec); Iterator\u0026lt;Item\u0026gt; itemsIter = items.iterator(); while (itemsIter.hasNext()) { Item item = itemsIter.next(); ObjectMapper mapper = new ObjectMapper(); mapper.setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE); musicList.add(mapper.readValue(item.toJSON(), Music.class)); } return musicList; } public List\u0026lt;Music\u0026gt; queryItemByGSI(Music music) throws JsonProcessingException { List\u0026lt;Music\u0026gt; musicList = new ArrayList\u0026lt;\u0026gt;(); QuerySpec spec = new QuerySpec() .withKeyConditionExpression(\u0026#34;Upc = :v_upc\u0026#34;) .withValueMap(new ValueMap().withString(\u0026#34;:v_upc\u0026#34;, music.getUpc())); ItemCollection\u0026lt;QueryOutcome\u0026gt; items = gsiAlbum.query(spec); Iterator\u0026lt;Item\u0026gt; itemsIter = items.iterator(); while (itemsIter.hasNext()) { Item item = itemsIter.next(); ObjectMapper mapper = new ObjectMapper(); mapper.setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE); musicList.add(mapper.readValue(item.toJSON(), Music.class)); } return musicList; } }   Controller for CRUD\n@Controller(\u0026#34;/music\u0026#34;) public class MusicController { private static final Logger log = LoggerFactory.getLogger(MusicController.class); @Inject MusicDao musicDao; @Inject ObjectMapper mapper; @Get(\u0026#34;{?music*}\u0026#34;) // this is used to mapping request parameters  @Produces(MediaType.APPLICATION_JSON) public HttpResponse getEvent(Music music) { Music item = musicDao.getItem(music); if (item == null) { final ItemError notFound = ItemError.builder() .status(HttpStatus.NOT_FOUND.getCode()) .error(HttpStatus.NOT_FOUND.name()) .message(\u0026#34;item not found\u0026#34;) .build(); return HttpResponse.notFound(notFound); } return HttpResponse.ok(item); } @Get(\u0026#34;/query/lsi{?music*}\u0026#34;) @Produces(MediaType.APPLICATION_JSON) public HttpResponse getEventByLSI(Music music) throws JsonProcessingException { List\u0026lt;Music\u0026gt; items = musicDao.queryItemByLSI(music); if (items.isEmpty()) { final ItemError notFound = ItemError.builder() .status(HttpStatus.NOT_FOUND.getCode()) .error(HttpStatus.NOT_FOUND.name()) .message(\u0026#34;item not found\u0026#34;) .build(); return HttpResponse.notFound(notFound); } return HttpResponse.ok(items); } @Get(\u0026#34;/query/gsi{?music*}\u0026#34;) @Produces(MediaType.APPLICATION_JSON) public HttpResponse getEventByGSI(Music music) throws JsonProcessingException { List\u0026lt;Music\u0026gt; items = musicDao.queryItemByGSI(music); if (items.isEmpty()) { final ItemError notFound = ItemError.builder() .status(HttpStatus.NOT_FOUND.getCode()) .error(HttpStatus.NOT_FOUND.name()) .message(\u0026#34;item not found\u0026#34;) .build(); return HttpResponse.notFound(notFound); } return HttpResponse.ok(items); } @Post @Produces(MediaType.APPLICATION_JSON) public HttpResponse saveEvent(@Body String body) throws JsonProcessingException { musicDao.saveItem(mapper.readValue(body, Music.class)); return HttpResponse.ok(); } @Delete @Produces(MediaType.APPLICATION_JSON) public HttpResponse deleteEvent(@Body String body) throws JsonProcessingException { musicDao.deleteItem(mapper.readValue(body, Music.class)); return HttpResponse.ok(); } }   终于到了测试了\n建立几个helper method：\nprivate void saveItem(final Music music) throws JsonProcessingException { final String body = mapper.writeValueAsString(music); client.toBlocking().exchange(HttpRequest.POST(\u0026#34;/\u0026#34;, body)); } // getItem要用partitionKey  private Music getItem(final Music music) { final String uri = new UriTemplate(\u0026#34;/{?artist,songTitle}\u0026#34;).expand(music); return client.toBlocking().retrieve(HttpRequest.GET(uri), Music.class); } // LSI和GSI需要用scan或者query  private String queryItemsByLSI(Music music) { final String uri = new UriTemplate(\u0026#34;/query/lsi{?artist,albumTitle}\u0026#34;).expand(music); return client.toBlocking().retrieve(HttpRequest.GET(uri)); } private String queryItemsByGSI(Music music) { final String uri = new UriTemplate(\u0026#34;/query/gsi{?upc}\u0026#34;).expand(music); return client.toBlocking().retrieve(HttpRequest.GET(uri)); } private void deleteItem(final Music music) throws JsonProcessingException { final String delBody = mapper.writeValueAsString(music); client.toBlocking().exchange(HttpRequest.DELETE(\u0026#34;/\u0026#34;,delBody)); } 测试：\n@Test void testGetEventByPartitionKey() throws JsonProcessingException { Music music = new Music(\u0026#34;Beyond\u0026#34;, \u0026#34;Love\u0026#34;, \u0026#34;Love\u0026#34;, 1993, \u0026#34;09000\u0026#34;); saveItem(music); // HashKey \u0026#34;Beyond\u0026#34;, RangeKey \u0026#34;Love\u0026#34;  Music requestMusic = new Music(\u0026#34;Beyond\u0026#34;, \u0026#34;Love\u0026#34;, null, null, null); Music result = getItem(requestMusic); assertTrue(result.getArtist().equals(\u0026#34;Beyond\u0026#34;)); assertTrue(result.getAlbumTitle().equals(\u0026#34;Love\u0026#34;)); assertTrue(result.getYear() == 1993); } @Test void testGetEventByLSI() throws JsonProcessingException { Music music = new Music(\u0026#34;Maroon 5\u0026#34;, \u0026#34;One More Night\u0026#34;, \u0026#34;Overexposed\u0026#34;, 2012, \u0026#34;20120123\u0026#34;); saveItem(music); Music music1 = new Music(\u0026#34;Maroon 5\u0026#34;, \u0026#34;Payphone\u0026#34;, \u0026#34;Overexposed\u0026#34;, 2012, \u0026#34;20120124\u0026#34;); saveItem(music1); // HashKey: \u0026#34;Maroon 5\u0026#34;, LSI RangeKey: \u0026#34;Overexposed\u0026#34;  Music requestMusic = new Music(\u0026#34;Maroon 5\u0026#34;, null, \u0026#34;Overexposed\u0026#34;, null, null); String musics = queryItemsByLSI(requestMusic); List\u0026lt;Music\u0026gt; musicList; musicList = mapper.readValue(musics, new TypeReference\u0026lt;\u0026gt;() {}); Collections.sort(musicList, Comparator.comparing(Music::getUpc)); assertTrue(musicList.size() == 2); assertTrue(musicList.get(0).getUpc().equals(\u0026#34;20120123\u0026#34;)); assertTrue(musicList.get(1).getUpc().equals(\u0026#34;20120124\u0026#34;)); } @Test void testGetEventByGSI() throws JsonProcessingException { Music music = new Music(\u0026#34;MJ\u0026#34;, \u0026#34;Dangerous\u0026#34;, \u0026#34;Dangerous\u0026#34;, 1991, \u0026#34;MJ-19910123\u0026#34;); saveItem(music); // GSI HashKey: \u0026#34;MJ-19910123\u0026#34;  Music requestMusic = new Music(null, null, null, null, \u0026#34;MJ-19910123\u0026#34;); String musics = queryItemsByGSI(requestMusic); List\u0026lt;Music\u0026gt; musicList; musicList = mapper.readValue(musics, new TypeReference\u0026lt;\u0026gt;() {}); assertTrue(musicList.size() == 1); assertTrue(musicList.get(0).getUpc().equals(\u0026#34;MJ-19910123\u0026#34;)); assertTrue(musicList.get(0).getArtist().equals(\u0026#34;MJ\u0026#34;)); assertTrue(musicList.get(0).getSongTitle().equals(\u0026#34;Dangerous\u0026#34;)); assertTrue(musicList.get(0).getAlbumTitle().equals(\u0026#34;Dangerous\u0026#34;)); assertTrue(musicList.get(0).getYear().equals(1991)); } @Test void testDeleteEvent() throws JsonProcessingException { Music music = new Music(\u0026#34;Robin\u0026#34;, \u0026#34;Angel\u0026#34;, \u0026#34;Angel\u0026#34;, 2000, \u0026#34;08000\u0026#34;); saveItem(music); Music delRequest = new Music(\u0026#34;Robin\u0026#34;, \u0026#34;Angel\u0026#34;, null, null, null); deleteItem(delRequest); Music request = new Music(\u0026#34;Robin\u0026#34;, \u0026#34;Angel\u0026#34;, null, null, null); try { getItem(request); } catch (HttpClientResponseException e) { assertEquals(HttpStatus.NOT_FOUND, e.getResponse().getStatus()); Optional\u0026lt;ItemError\u0026gt; jsonError = e.getResponse().getBody(ItemError.class); assertTrue(jsonError.isPresent()); log.debug(\u0026#34;Custom Error: {}\u0026#34;, jsonError.get()); assertEquals(404, jsonError.get().getStatus()); assertEquals(\u0026#34;NOT_FOUND\u0026#34;, jsonError.get().getError()); assertEquals(\u0026#34;item not found\u0026#34;, jsonError.get().getMessage()); } }   参考  https://github.com/aaronshaf/dynamodb-admin https://github.com/instructure/dynamo-local-admin-docker  ","date":"March 16, 2021","hero":"/posts/aws/dynamodb-admin/hero.svg","permalink":"https://shubozhang.github.io/posts/aws/dynamodb-admin/","summary":"DynamoDB一直被人诟病没有好的query tool，查询数据很麻烦，到现在也没有。在就是本地开发不是很友好，AWS提供了Dynamodb Local，但是aws cli query数据 还是很麻烦。今天推荐一个给DynamoDB Local做的Graphical User Interface (GUI)\u0026mdash;dynamodb-admin，可以像在AWS console一样，让本地数据可视化和操作化。\n快速设置   通过npm安装dynamodb-admin\nnpm install -g dynamodb-admin   运行docker： local dynamodb\ndocker-compose.yml file\nversion: \u0026#39;3.8\u0026#39;services: dynamodb-local: command: \u0026#34;-jar DynamoDBLocal.jar -sharedDb -optimizeDbBeforeStartup -dbPath ./data\u0026#34; image: \u0026#34;amazon/dynamodb-local:latest\u0026#34; container_name: dynamodb-local ports: - \u0026#34;8000:8000\u0026#34; volumes: - \u0026#34;./docker/dynamodb:/home/dynamodblocal/data\u0026#34; working_dir: /home/dynamodblocalRun docker-compose.yml file\ndocker-compose up -d   启动dynamodb-admin\n MacOS： dynamodb-admin // 或者定义region和credentials AWS_REGION=eu-west-1 AWS_ACCESS_KEY_ID=local AWS_SECRET_ACCESS_KEY=local dynamodb-admin  Windows: export DYNAMO_ENDPOINT=http://localhost:8000 dynamodb-admin     完成","tags":null,"title":"介绍一个本地DynamoDB图形界面应用: dynamodb-admin"},{"categories":null,"contents":"公司的产品是部署在全世界不同地区的服务器上的，为了一致，时间统一用UTC， 为了debug log方便，经常要参考GMT时间。有时和英国，印度等地方开会， 也需要查看各地时间。推荐下面这款免费软件，自己用了一段时间，很满意。\n世界时间显示  App Store： Menu World Time 效果图   特点  在menu bar直接显示世界多个城市时间 点击图标显示多个城市时间 显示黄昏，日落， 黎明，薄暮等等 可以添加世界任意地方时间  我自己的使用\n","date":"March 1, 2021","hero":"/posts/tools/mac-world-time/time.png","permalink":"https://shubozhang.github.io/posts/tools/mac-world-time/","summary":"公司的产品是部署在全世界不同地区的服务器上的，为了一致，时间统一用UTC， 为了debug log方便，经常要参考GMT时间。有时和英国，印度等地方开会， 也需要查看各地时间。推荐下面这款免费软件，自己用了一段时间，很满意。\n世界时间显示  App Store： Menu World Time 效果图   特点  在menu bar直接显示世界多个城市时间 点击图标显示多个城市时间 显示黄昏，日落， 黎明，薄暮等等 可以添加世界任意地方时间  我自己的使用","tags":null,"title":"MacOS - Menu World Time"},{"categories":null,"contents":"MacOS自带的Activity Monitor，如果你想在menu bar上可以时时 监控，推荐下面这个开源app。相比较其他app，我最喜欢这款app可以显示数字进度，不是用bar。\nStats  App：https://github.com/exelban/stats 效果图   特点  CPU 使用 GPU 使用 内存使用 硬盘使用 传感器(温度/电压/电力) 电池使用 网络速度 风扇速度  ","date":"March 1, 2021","hero":"/posts/tools/mac-stats/monitor.png","permalink":"https://shubozhang.github.io/posts/tools/mac-stats/","summary":"MacOS自带的Activity Monitor，如果你想在menu bar上可以时时 监控，推荐下面这个开源app。相比较其他app，我最喜欢这款app可以显示数字进度，不是用bar。\nStats  App：https://github.com/exelban/stats 效果图   特点  CPU 使用 GPU 使用 内存使用 硬盘使用 传感器(温度/电压/电力) 电池使用 网络速度 风扇速度  ","tags":null,"title":"MacOS - 系统监视软件"},{"categories":null,"contents":"微服务规模大了以后，传统build 的docker image就显得非常臃肿，启动慢，体积大，非常不利于scale， 资源消耗也大。一般提高方法就是使用轻量级模块注入，用什么，加什么， 并且不用大的框架，像Spring， Spring boot就 非常不推荐在为服务使用。。。\n经过上面优化，性能会好一些，但没啥惊人变化， 因为base image还是openjdk，依赖注入，反射，注解之类 还是会降低启动速度。\nGraalVM（https://www.graalvm.org/） GraalVM作为一款新型通用的虚拟机，不废话，单刀直入解决问题，启动快50倍，内存消耗少5倍。\n为啥它这么牛，因为它用AOT(ahead-of-time)编译，可以快速启动和低内存消耗。官方列的优点：\n 高效 AOT 编译 （快速启动） 多语言 高级工具（调试，监控，profile等等）  后两项还没有特别感觉，因为公司后台主要用Java/Kotlin/Grrovy，没有多语言问题。高级工具这些，公司有统一的stack，也不准备用。\nMicronaut（https://github.com/micronaut-projects/micronaut-core） Micronaut是一款现代, 基于JVM的全栈Java框架，适用于模块化搭建，易于测试的JVM应用，支持Java, Kotlin和Groovy. 它提供了编译时的依赖注入和AOP处理能力，并最小化反射和动态代理的使用。它应用有着更快的启动速度和更低的内存占用。\nMicronaut + GraalVM （POC）   用Micronaut template创建一个App\n version: 2.3.3 language: Java 11 build: gradle test: jUnit feature： netty-server    创建一个简单的API\n  @Controller(\u0026quot;/hello\u0026quot;) public class HelloController { @Get(\u0026quot;/\u0026quot;) public String index() { return \u0026quot;hello from Micronaut + GraalVM\u0026quot;; } } 添加lib到build.gradle  annotationProcessor(\u0026quot;io.micronaut:micronaut-graal\u0026quot;) compileOnly(\u0026quot;org.graalvm.nativeimage:svm\u0026quot;) 新建src/main/resources/META-INF/native-image/native-image.properties  Args= -H:IncludeResources=logback.xml|application.yml \\ -H:Name=mn-graalvm \\ -H:Class=com.sz.App \\ --report-unsupported-elements-at-runtime Dockerfile  # this image is only used in building, not for runtime FROM ghcr.io/graalvm/graalvm-ce:latest as graalvm # gu = graal updater RUN gu install native-image COPY . /home/app/mn-graalvm WORKDIR /home/app/mn-graalvm RUN native-image --no-server -cp build/libs/mn-graalvm-*-all.jar FROM frolvlad/alpine-glibc:alpine-3.12 RUN apk update \u0026amp;\u0026amp; apk add libstdc++ # No rest api, so no port to expose EXPOSE 8080 COPY --from=graalvm /home/app/mn-graalvm/mn-graalvm /app/mn-graalvm ENTRYPOINT [\u0026quot;/app/mn-graalvm\u0026quot;] Build   ./gradlew clean assemble docker build . -t mn-graalvm  提示，这个过程比较消耗时间和资源，分配给docker6～8GB内存，否则容易报错\n结果 启动时间比较   GraalVM原生 (32 ms)   非原生（961 ms）   镜像大小  原生 81MB， 非原生251MB   内存使用   原生 (7.64 MB)   非原生 (47.27 MB)   比较总结     原生 非原生     启动时间 32 ms 961 ms   镜像大小 81 MB 251MB   内存使用 7 MB 47MB    通过比较一个最简单的web app来看，GraalVM效果性能还是不错，启动时间和内存使用这两项还是很吸引人的。下一步用大项目，可以 对性能进一步的比较和分析。\n源码: https://github.com/shubozhang/micronaut-with-java/tree/main/mn-graalvm\n","date":"March 1, 2021","hero":"/posts/micronaut/mn-graalvm/index.png","permalink":"https://shubozhang.github.io/posts/micronaut/mn-graalvm/","summary":"微服务规模大了以后，传统build 的docker image就显得非常臃肿，启动慢，体积大，非常不利于scale， 资源消耗也大。一般提高方法就是使用轻量级模块注入，用什么，加什么， 并且不用大的框架，像Spring， Spring boot就 非常不推荐在为服务使用。。。\n经过上面优化，性能会好一些，但没啥惊人变化， 因为base image还是openjdk，依赖注入，反射，注解之类 还是会降低启动速度。\nGraalVM（https://www.graalvm.org/） GraalVM作为一款新型通用的虚拟机，不废话，单刀直入解决问题，启动快50倍，内存消耗少5倍。\n为啥它这么牛，因为它用AOT(ahead-of-time)编译，可以快速启动和低内存消耗。官方列的优点：\n 高效 AOT 编译 （快速启动） 多语言 高级工具（调试，监控，profile等等）  后两项还没有特别感觉，因为公司后台主要用Java/Kotlin/Grrovy，没有多语言问题。高级工具这些，公司有统一的stack，也不准备用。\nMicronaut（https://github.com/micronaut-projects/micronaut-core） Micronaut是一款现代, 基于JVM的全栈Java框架，适用于模块化搭建，易于测试的JVM应用，支持Java, Kotlin和Groovy. 它提供了编译时的依赖注入和AOP处理能力，并最小化反射和动态代理的使用。它应用有着更快的启动速度和更低的内存占用。\nMicronaut + GraalVM （POC）   用Micronaut template创建一个App\n version: 2.3.3 language: Java 11 build: gradle test: jUnit feature： netty-server    创建一个简单的API\n  @Controller(\u0026quot;/hello\u0026quot;) public class HelloController { @Get(\u0026quot;/\u0026quot;) public String index() { return \u0026quot;hello from Micronaut + GraalVM\u0026quot;; } } 添加lib到build.","tags":null,"title":"Micronaut + GraalVM 是不是真的香"},{"categories":null,"contents":"每当我想快速看看接下来的日期的时候，就不自觉的会去点击menu bar的日历，每次都很懵， 它怎么不显示日历呢～～～这时候我一般去打开网页看了。后来又发生了几次，觉得常用功能应该花时间设置一下， 可能default不显示，改一下就可以。结果搞了半天还是不行，是不是我打开方式不对 :( 在去网上搜了下，还是不行，这是搞啥呢\n推荐下这个免费的cal tool - Itsycal  下载主页： https://www.mowglii.com/itsycal/ 效果图   特点 我用了2年左右，感觉基本功能还是很实用\n 可以高亮周末 可以设置周一为第一天，方便查看 可以显示周数，很方便写周计划，报告报表 可以加提醒，或者sync up icloud events 多种时间显示格式  ","date":"February 15, 2021","hero":"/posts/tools/itsycal/itsycal.png","permalink":"https://shubozhang.github.io/posts/tools/itsycal/","summary":"每当我想快速看看接下来的日期的时候，就不自觉的会去点击menu bar的日历，每次都很懵， 它怎么不显示日历呢～～～这时候我一般去打开网页看了。后来又发生了几次，觉得常用功能应该花时间设置一下， 可能default不显示，改一下就可以。结果搞了半天还是不行，是不是我打开方式不对 :( 在去网上搜了下，还是不行，这是搞啥呢\n推荐下这个免费的cal tool - Itsycal  下载主页： https://www.mowglii.com/itsycal/ 效果图   特点 我用了2年左右，感觉基本功能还是很实用\n 可以高亮周末 可以设置周一为第一天，方便查看 可以显示周数，很方便写周计划，报告报表 可以加提醒，或者sync up icloud events 多种时间显示格式  ","tags":null,"title":"MacOS日历 - Itsycal"},{"categories":null,"contents":"Use Intention-Revealing Names The name of a variable, function, or class, should answer all the big questions. It should tell you\n why it exists what it does how it is used.  Bad example: If a name requires a comment, then the name does not reveal its intent.\nint d; // elapsed time in days The name d reveals nothing. It does not evoke a sense of elapsed time, nor of days.\nGood example: We should choose a name that specifies what is being measured and the unit of that measurement:\nint elapsedTimeInDays; int daysSinceCreation; int daysSinceModification; int fileAgeInDays; Avoid Disinformation Programmers must avoid leaving false clues that obscure the meaning of code.\n  We should avoid words whose entrenched meanings vary from our intended meaning. For example, hp, aix, and sco would be poor variable names because they are the names of Unix platforms or variants.\n  Naming a grouping of accounts that properly reflect its property.\n accountList if it’s a List. accountSet if it’s a Set. accountMap if it’s a Map. just plain accounts .    Make Meaningful Distinctions  Number-series naming (a1, a2, .. aN) is the opposite of intentional naming. Noise words are another meaningless distinction. getActiveAccount(); getActiveAccounts(); getActiveAccountInfo();   Use Pronounceable Names Use Searchable Names Suggestion: single-letter names can ONLY be used as local variables inside short methods. The length of a name should correspond to the size of its scope.\nAvoid Encodings Avoid Mental Mapping One difference between a smart programmer and a professional programmer is that the professional understands that clarity is king. Professionals use their powers for good and write code that others can understand.\nClass Names Classes and objects should have noun or noun phrase names like Customer, WikiPage, Account, and AddressParser. Avoid words like Manager, Processor, Data, or Info in the name of a class. A class name should not be a verb.\nMethod Names Methods should have verb or verb phrase names like postPayment, deletePage, or save. Accessors, mutators, and predicates should be named for their value and prefixed with get, set, and is according to the javabean standard\nDon’t Be Cute Pick One Word per Concept Pick one word for one abstract concept and stick with it. For instance, it’s confusing to have fetch, retrieve, and get as equivalent methods of different classes.\nLikewise, it’s confusing to have a controller and a manager and a driver in the same code base. What is the essential difference between a DeviceManager and a Protocol-Controller? Why are both not controllers or both not managers? Are they both Drivers really? The name leads you to expect two objects that have very different type as well as having different classes.\nA consistent lexicon is a great boon to the programmers who must use your code.\nDon’t Pun Avoid using the same word for two purposes. Using the same term for two different ideas is essentially a pun.\nUse Solution Domain Names Remember that the people who read your code will be programmers. So go ahead and use computer science (CS) terms, algorithm names, pattern names, math terms, and so forth.\nThe name AccountVisitor means a great deal to a programmer who is familiar with the VISITOR pattern. What programmer would not know what a JobQueue was? There are lots of very technical things that programmers have to do. Choosing technical names for those things is usually the most appropriate course.\nUse Problem Domain Names When there is no “programmer-eese” for what you’re doing, use the name from the problem domain. At least the programmer who maintains your code can ask a domain expert what it means. Separating solution and problem domain concepts is part of the job of a good programmer and designer. The code that has more to do with problem domain concepts should have names drawn from the problem domain.\nAdd Meaningful Context Imagine that you have variables named firstName, lastName, street, houseNumber, city, state, and zipcode. Taken together it’s pretty clear that they form an address. But what if you just saw the state variable being used alone in a method? Would you automatically infer that it was part of an address?\nYou can add context by using prefixes: addrFirstName, addrLastName, addrState, and so on. At least readers will understand that these variables are part of a larger structure. Of course, a better solution is to create a class named Address. Then, even the compiler knows that the variables belong to a bigger concept.\nDon’t Add Gratuitous Context In an imaginary application called “Gas Station Deluxe,” it is a bad idea to prefix every class with GSD. Frankly, you are working against your tools. You type G and press the completion key and are rewarded with a mile-long list of every class in the system. Is that wise? Why make it hard for the IDE to help you?\nLikewise, say you invented a MailingAddress class in GSD’s accounting module, and you named it GSDAccountAddress. Later, you need a mailing address for your customer con- tact application. Do you use GSDAccountAddress? Does it sound like the right name? Ten of 17 characters are redundant or irrelevant.\nShorter names are generally better than longer ones, so long as they are clear. Add no more context to a name than is necessary. The names accountAddress and customerAddress are fine names for instances of the class Address but could be poor names for classes. Address is a fine name for a class. If I need to differentiate between MAC addresses, port addresses, and Web addresses, I might consider PostalAddress, MAC, and URI. The resulting names are more precise, which is the point of all naming.\nFinal Words The hardest thing about choosing good names is that it requires good descriptive skills and a shared cultural background. This is a teaching issue rather than a technical, business, or management issue. As a result many people in this field don’t learn to do it very well.\nPeople are also afraid of renaming things for fear that some other developers will object. We do not share that fear and find that we are actually grateful when names change (for the better).\nMost of the time we don’t really memorize the names of classes and methods. We use the modern tools to deal with details like that so we can focus on whether the code reads like paragraphs and sentences, or at least like tables and data structure (a sentence isn’t always the best way to display data). You will probably end up surprising someone when you rename, just like you might with any other code improvement.\nDon’t let it stop you in your tracks. Follow some of these rules and see whether you don’t improve the readability of your code. If you are maintaining someone else’s code, use refactoring tools to help resolve these problems. It will pay off in the short term and continue to pay in the long run.\n","date":"January 16, 2021","hero":"/posts/software-design-and-engineering/clean-code/01-meaningful-names/clean-code.jpg","permalink":"https://shubozhang.github.io/posts/software-design-and-engineering/clean-code/01-meaningful-names/","summary":"Use Intention-Revealing Names The name of a variable, function, or class, should answer all the big questions. It should tell you\n why it exists what it does how it is used.  Bad example: If a name requires a comment, then the name does not reveal its intent.\nint d; // elapsed time in days The name d reveals nothing. It does not evoke a sense of elapsed time, nor of days.","tags":null,"title":"Meaningful Names"},{"categories":null,"contents":"How many ways to use count?  count(*): returns a count of the number of all rows (including NULL). count(1): 1 evaludates to non-NULL for every row, so it returns the same results as count(*) count(col_name): returns a count of the number of the rows that col_name is not NULL  count(col_name) VS count(*)？  count(*): returns a count of the number of all rows (including NULL). count(col_name): returns a count of the number of the rows that col_name is not NULL count(*) is recommended even though count(pk) can return the same result. Because MySQL optimizes count(*) and makes it work more efficient. Note, this optimization does not work when where and group by in the query.  count(1) VS count(*) ?  count(*) is prefered. Because it is SQL92 standard syntax. In MySql, they should have the same performance. In PostgreSQL, it seems count(*) is faster about 10% than count(1).  ","date":"December 20, 2020","hero":"/posts/db/mysql-count/mysql-logo.png","permalink":"https://shubozhang.github.io/posts/db/mysql-count/","summary":"How many ways to use count?  count(*): returns a count of the number of all rows (including NULL). count(1): 1 evaludates to non-NULL for every row, so it returns the same results as count(*) count(col_name): returns a count of the number of the rows that col_name is not NULL  count(col_name) VS count(*)？  count(*): returns a count of the number of all rows (including NULL). count(col_name): returns a count of the number of the rows that col_name is not NULL count(*) is recommended even though count(pk) can return the same result.","tags":null,"title":"How to Use MySQL count"},{"categories":null,"contents":"A common requirement is to monitor S3 bucket activities, especially for the purpose of auditing. In this blog, I will introduce three ways to implement this feature.\n1. Use S3 properties Enable Server Access Logging for an S3 Bucket. It is one of the S3 bucket properties. You just need to select a target bucket and prefix to complete the setup. The details are available here: https://docs.aws.amazon.com/AmazonS3/latest/user-guide/server-access-logging.html\n Pros:  less infrastructure no code involved easy to search log for a specific bucket.   Cons:  the target bucket must be in public ip which is a deal breaker sometimes. no UI.    2. Use CloudTrail Use CloudTrail to create a trail to monitor S3 bucket.\n Pros:  less infrastructure no code involved UI for browsing works for both private and public ip target bucket.   Cons:  when monitoring multiple buckets, it is not easy to search a specific bucket log since there is no prefix setup for each source bucket.    3. Use Lambda Use Lambda to capture S3 bucket events.\n Pros:  easy customized search works for both private and public for target bucket   Cons:  more infrastructure code involved no UI.    I used method 3 in my application. Since method 1 requires public ip for target bucket which breaks security policy. Method 2 is a perfect solution if we only need to monitor one S3 bucket. For monitoring multiple buckets, it is really not easy to search activities for a specific bucket log. Method 3 works well for monitor multiple S3 buckets, but like I mentioned before it needs to maintain infrastructure, although the code is simple.\n","date":"December 20, 2020","hero":"/posts/aws/3-ways-to-log-s3/s3-logo.svg","permalink":"https://shubozhang.github.io/posts/aws/3-ways-to-log-s3/","summary":"A common requirement is to monitor S3 bucket activities, especially for the purpose of auditing. In this blog, I will introduce three ways to implement this feature.\n1. Use S3 properties Enable Server Access Logging for an S3 Bucket. It is one of the S3 bucket properties. You just need to select a target bucket and prefix to complete the setup. The details are available here: https://docs.aws.amazon.com/AmazonS3/latest/user-guide/server-access-logging.html\n Pros:  less infrastructure no code involved easy to search log for a specific bucket.","tags":null,"title":"Three ways to log S3 Bucket Activities"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://shubozhang.github.io/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"}]